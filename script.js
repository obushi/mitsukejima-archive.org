const translations = {
  ja: {
    brand: "見附島アーカイブ",
    navAbout: "見附島とは",
    navDamage: "被害を知る",
    navPhoto: "変化を見守る",
    nav3d: "ギャラリー",
    heroTitle: "見附島アーカイブへようこそ",
    heroDescription:
      "能登半島地震により大きく姿を変えた見附島。その記憶と景観を未来へつなぐための記録プロジェクトです。",
    aboutTitle: "見附島とは",
    aboutBody:
      "見附島は石川県珠洲市に位置する高さ約30メートルの奇岩です。その姿から「軍艦島」とも呼ばれてきました。古くから地域の象徴として親しまれ、周囲の自然とともに多くの人々を魅了してきました。",
    damageTitle: "被害を知る",
    damageBody:
      "2024年元日の能登半島地震により、見附島の表面や周辺の地形が大きく損傷を受けました。崩落した岩肌や変化した海岸線は、災害の影響を物語っています。本アーカイブでは、被災前後の姿を比較し、被害の実態をわかりやすく伝えていきます。",
    damageVideoTitle: "被災前後の動画比較",
    damageVideoDescription: "スライダーを動かして、被災前後の映像を同時に確認できます。",
    photoTitle: "変化を見守る",
    photoBody:
      "震災により姿を変えた見附島では、今も緑が広がり続けています。オンラインで収集した写真をもとに、見附島の変化を可視化するタイムラプス映像を作成中です。写真の提供ご協力いただける方はプロジェクトチームまでご連絡ください。",
    modelsTitle: "ギャラリー",
    modelsBody:
      "ドローン撮影で得た映像を活用し、見附島の精密な3Dシーンを構築しています。完成したデータは、さまざまな用途に活用いただけるよう公開しています。また、今後も撮影を継続して参ります。",
    aboutImageAlt: "2023年11月に撮影された見附島の写真",
    damageImageAlt: "地震で崩落した見附島の岩肌の近接写真",
    timelapseBeforeAlt: "被災前の見附島を撮影した写真",
    timelapseAfterAlt: "被災後の見附島を撮影した写真",
    timelapseRidgeBeforeAlt: "被災前の見附島の稜線を撮影した写真",
    timelapseRidgeAfterAlt: "被災後の見附島の稜線を撮影した写真",
    damageVideoBeforeLabel: "2022年6月20日撮影",
    damageVideoAfterLabel: "2025年8月13日撮影",
    timelapseRidgeBeforeLabel: "2024年2月4日撮影",
    timelapseRidgeAfterLabel: "2025年8月13日撮影",
    timelapseShoreBeforeLabel: "2025年5月26日撮影",
    timelapseShoreAfterLabel: "2025年8月13日撮影",
    timelapseContributionLink: "写真を投稿する",
    comparisonAria: "スライダーを左右に動かして画像や映像を比較",
    footerCopyright: "© 2025 見附島アーカイブ",
    footerTerms: "利用規約",
    termsTitle: "利用規約",
    termsBody:
      "本アーカイブに掲載されている写真、映像、3Dモデルなどの著作物を無断で複製・配布・改変することを禁じます。利用に関するお問い合わせはプロジェクトチームまでご連絡ください。",
    termsBack: "トップページに戻る",
  },
  en: {
    brand: "Mitsukejima Archive",
    navAbout: "About Mitsukejima Island",
    navDamage: "Earthquake Damage",
    navPhoto: "Photo Collection",
    nav3d: "Gallery",
    heroTitle: "Welcome to the Mitsukejima Archive",
    heroDescription:
      "This project preserves the changing landscape of Mitsukejima after the Noto Peninsula earthquake so future generations can remember and learn from it.",
    aboutTitle: "About Mitsukejima",
    aboutBody:
      "Mitsukejima is a striking 30-metre rock formation off Suzu City in Ishikawa Prefecture. Resembling a ship cutting through the waves, it has long been nicknamed the \"Warship Island\" and cherished as a symbol of the region.",
    damageTitle: "Understanding the Damage",
    damageBody:
      "The 2024 Noto Peninsula earthquake severely scarred the rock surface and coastline surrounding Mitsukejima. Collapsed cliffs and the reshaped shoreline show the scale of the disaster. This archive compares the island before and after the quake to communicate the realities of the damage.",
    damageVideoTitle: "Video Comparison",
    damageVideoDescription: "Drag the slider to crossfade and compare footage of Mitsukejima before and after the earthquake.",
    photoTitle: "Building the Time-lapse",
    photoBody:
      "With contributions from local residents and supporters, we are composing a time-lapse that visualises Mitsukejima's changes over time. If you have photographs or information to share, please get in touch with the project team.",
    modelsTitle: "Gallery",
    modelsBody:
      "Using drone imaging and photogrammetry, we are constructing detailed 3D models of Mitsukejima. Once completed, the models will be released for disaster research, tourism promotion, and community education.",
    aboutImageAlt: "Sunset view of Mitsukejima rising from the sea",
    damageImageAlt: "Close-up of Mitsukejima's eroded rock face after the earthquake",
    timelapseBeforeAlt: "Photograph of Mitsukejima before the earthquake",
    timelapseAfterAlt: "Photograph of Mitsukejima after the earthquake",
    timelapseRidgeBeforeAlt: "Ridgeline view of Mitsukejima before the earthquake",
    timelapseRidgeAfterAlt: "Ridgeline view of Mitsukejima after the earthquake",
    damageVideoBeforeLabel: "Before Footage",
    damageVideoAfterLabel: "After Footage",
    timelapseRidgeBeforeLabel: "Before (Ridgeline)",
    timelapseRidgeAfterLabel: "After (Ridgeline)",
    timelapseShoreBeforeLabel: "Before (Panorama)",
    timelapseShoreAfterLabel: "After (Panorama)",
    timelapseContributionLink: "Submit Photos",
    comparisonAria: "Move the slider to compare the images or footage",
    footerCopyright: "© 2025 Mitsukejima Archive",
    footerTerms: "Terms of Use",
    termsTitle: "Terms of Use",
    termsBody:
      "All photographs, videos, and 3D models in this archive are protected works. Reuse, distribution, or modification without permission is prohibited. Please contact the project team for usage inquiries.",
    termsBack: "Back to Home",
  },
};

const languageSelect = document.getElementById("language-select");
const menuToggle = document.querySelector(".menu-toggle");
const siteHeader = document.querySelector(".site-header");
const navLinks = document.querySelectorAll(".primary-nav a");
const brandLink = document.querySelector(".brand");

const easeInOutCubic = (t) =>
  t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

const smoothScrollTo = (target) => {
  if (!target) {
    return;
  }

  const startY = window.pageYOffset;
  const headerOffset = siteHeader?.offsetHeight || 0;
  const targetRect = target.getBoundingClientRect();
  const targetY = targetRect.top + window.pageYOffset - headerOffset;
  const distance = targetY - startY;
  const duration = 600;
  let startTime = null;

  const step = (currentTime) => {
    if (startTime === null) {
      startTime = currentTime;
    }

    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = easeInOutCubic(progress);

    window.scrollTo(0, startY + distance * eased);

    if (elapsed < duration) {
      requestAnimationFrame(step);
    }
  };

  requestAnimationFrame(step);
};

const applyTranslations = (lang) => {
  const strings = translations[lang];
  if (!strings) {
    return;
  }

  document.documentElement.lang = lang;

  document.querySelectorAll("[data-i18n]").forEach((node) => {
    const key = node.getAttribute("data-i18n");
    const value = strings[key];
    if (value !== undefined) {
      node.textContent = value;
    }
  });

  document.querySelectorAll("[data-i18n-alt]").forEach((node) => {
    const key = node.getAttribute("data-i18n-alt");
    const value = strings[key];
    if (value !== undefined) {
      node.setAttribute("alt", value);
    }
  });

  document.querySelectorAll("[data-i18n-aria]").forEach((node) => {
    const key = node.getAttribute("data-i18n-aria");
    const value = strings[key];
    if (value !== undefined) {
      node.setAttribute("aria-label", value);
    }
  });
};

const closeMenu = () => {
  siteHeader.classList.remove("nav-open");
  if (menuToggle) {
    menuToggle.setAttribute("aria-expanded", "false");
  }
};

const initNavigation = () => {
  if (!menuToggle || !siteHeader) {
    return;
  }

  menuToggle.addEventListener("click", () => {
    const isOpen = siteHeader.classList.toggle("nav-open");
    menuToggle.setAttribute("aria-expanded", String(isOpen));
  });

  navLinks.forEach((link) => {
    link.addEventListener("click", (event) => {
      const href = link.getAttribute("href");
      if (href && href.startsWith("#")) {
        const target = document.querySelector(href);
        if (target) {
          event.preventDefault();
          smoothScrollTo(target);
        }
      }
      closeMenu();
    });
  });

  if (
    brandLink &&
    brandLink.getAttribute("href") === "index.html" &&
    /index\.html?$/.test(window.location.pathname)
  ) {
    brandLink.addEventListener("click", (event) => {
      event.preventDefault();
      const target = document.querySelector("#overview") || document.body;
      smoothScrollTo(target);
    });
  }
};

const initLanguage = () => {
  const initial = languageSelect?.value || "ja";
  applyTranslations(initial);

  languageSelect?.addEventListener("change", (event) => {
    const nextLanguage = event.target.value;
    applyTranslations(nextLanguage);
  });
};

const safePlay = (video) => {
  if (!video) {
    return;
  }
  const playPromise = video.play();
  if (playPromise && typeof playPromise.catch === "function") {
    playPromise.catch(() => {});
  }
};

const initVideoComparison = (container) => {
  const videos = container.querySelectorAll("video");
  if (videos.length < 2) {
    return;
  }

  const primary = videos[0];
  const secondary = videos[1];
  const threshold = 0.05;

  const syncCurrentTime = () => {
    if (!primary || !secondary) {
      return;
    }
    if (secondary.readyState === 0) {
      return;
    }
    if (Math.abs(primary.currentTime - secondary.currentTime) > threshold) {
      secondary.currentTime = primary.currentTime;
    }
  };

  const syncPlaybackState = () => {
    if (!primary || !secondary) {
      return;
    }

    if (primary.paused && !secondary.paused) {
      secondary.pause();
    } else if (!primary.paused && secondary.paused) {
      safePlay(secondary);
    }

    if (secondary.playbackRate !== primary.playbackRate) {
      secondary.playbackRate = primary.playbackRate;
    }
  };

  const syncFromPrimary = () => {
    syncCurrentTime();
    syncPlaybackState();
  };

  const primaryEvents = [
    "play",
    "pause",
    "seeking",
    "timeupdate",
    "ratechange",
    "loadeddata",
    "loadedmetadata",
  ];

  primaryEvents.forEach((eventName) => {
    primary.addEventListener(eventName, syncFromPrimary);
  });

  secondary.addEventListener("loadeddata", syncCurrentTime);
  secondary.addEventListener("seeking", syncCurrentTime);
  secondary.addEventListener("ratechange", () => {
    if (secondary.playbackRate !== primary.playbackRate) {
      secondary.playbackRate = primary.playbackRate;
    }
  });

  secondary.addEventListener("play", () => {
    if (primary.paused) {
      safePlay(primary);
    }
    syncFromPrimary();
  });

  primary.addEventListener("ended", () => {
    syncCurrentTime();
    syncPlaybackState();
  });

  if (primary.readyState >= 2) {
    syncFromPrimary();
  } else {
    primary.addEventListener("loadeddata", syncFromPrimary, { once: true });
  }
};

const initComparisons = () => {
  document.querySelectorAll("[data-comparison]").forEach((container) => {
    const input = container.querySelector(".comparison-input");
    if (!input) {
      return;
    }

    const update = (value) => {
      const clamped = Math.min(100, Math.max(0, Number(value)));
      container.style.setProperty("--position", clamped);
    };

    update(input.value);

    input.addEventListener("input", (event) => {
      update(event.target.value);
    });

    if (container.dataset.comparisonType === "video") {
      initVideoComparison(container);
    }
  });
};

const initScrollSpy = () => {
  document.body.classList.remove("theme-damage");

  if (!navLinks.length) {
    return;
  }

  const sections = Array.from(document.querySelectorAll("section[id]"));
  if (!sections.length) {
    return;
  }

  const linksById = new Map();
  navLinks.forEach((link) => {
    const href = link.getAttribute("href");
    if (!href || !href.includes("#")) {
      return;
    }
    const targetId = href.split("#").pop();
    if (targetId) {
      linksById.set(targetId, link);
    }
  });

  let currentActive = null;

  const setActiveLink = (id) => {
    const nextActive = id ? linksById.get(id) : undefined;
    if (!nextActive) {
      if (currentActive) {
        navLinks.forEach((link) => link.classList.remove("active"));
        currentActive = null;
      }
      return;
    }
    if (currentActive === nextActive) {
      return;
    }
    navLinks.forEach((link) => link.classList.remove("active"));
    nextActive.classList.add("active");
    currentActive = nextActive;
  };

  const applySectionTheme = (id) => {
    document.body.classList.toggle("theme-damage", id === "damage");
  };

  const getActiveSectionId = () => {
    const viewportPosition = window.scrollY + window.innerHeight * 0.35;
    let activeId = sections[0]?.id || null;
    sections.forEach((section) => {
      const offsetTop =
        section.getBoundingClientRect().top + window.scrollY;
      if (viewportPosition >= offsetTop) {
        activeId = section.id;
      }
    });
    return activeId;
  };

  let ticking = false;
  const handleUpdate = () => {
    ticking = false;
    const activeId = getActiveSectionId();
    setActiveLink(activeId);
    applySectionTheme(activeId);
  };

  const onScroll = () => {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(handleUpdate);
    }
  };

  window.addEventListener("scroll", onScroll, { passive: true });
  window.addEventListener("resize", onScroll);

  handleUpdate();
};

document.addEventListener("DOMContentLoaded", () => {
  initNavigation();
  initLanguage();
  initComparisons();
  initScrollSpy();
});
